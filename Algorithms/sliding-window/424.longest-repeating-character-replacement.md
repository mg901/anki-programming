## [424 Longest Repeating Character Replacement](https://leetcode.com/problems/longest-repeating-character-replacement/description/)

<!-- notecardId: 1764193149537 -->

```js
// Explanation:
// - Neetcode: https://youtu.be/gqXU1UyA8pk

// Sub-pattern:
// - Lazy Tracking & Variable-size window

// - Time: O(n)
// - Space: O(1)
function characterReplacement(s, k) {
  const ALPHABET_SIZE = 26;
  const counter = new Uint32Array(ALPHABET_SIZE);
  const A = 'A'.codePointAt(0);
  let maxFreq = 0;
  let longest = 0;

  let left = 0;

  for (let right = 0; right < s.length; right += 1) {
    const index = s.codePointAt(right) - A;
    counter[index] += 1;
    maxFreq = Math.max(maxFreq, counter[index]);
    const windowSize = right - left + 1;

    if (windowSize - maxFreq > k) {
      counter[s.codePointAt(left) - A] -= 1;
      left += 1;
    }

    longest = Math.max(longest, windowSize);
  }

  return longest;
}

// ðŸ§© Here's the intuition:
// We have a window of size windowSize = 5 and k = 1 (so we can replace at most 1 character).
//
// The window is valid if:
// windowSize - maxFreq <= k
// where maxFreq is the count of the most frequent character in the window.
//
// Scenario 1: everything fits
// windowSize = 5
// maxFreq = 4  // e.g., A A A A B
// 5 - 4 = 1 <= 1 â†’ valid
// So we can keep the window, longest = 5
//
// Scenario 2: window slides
// Suppose we remove one 'A', now it's A A A B B
// Real max frequency = 3, but maxFreq in code is still 4
//
// windowSize = 5
// maxFreq = 4 (overcounted)
// 5 - 4 = 1 <= 1 â†’ still "valid" in the code
//
// But in reality:
// 5 - 3 = 2 > 1 â†’ not valid
//
// You might think: "That's wrong!" â€” but it's not.
//
// Why? Because we don't update longest here!
// The algorithm only updates longest when windowSize - maxFreq <= k.
// And the length 5 was already recorded earlier when the window was really valid.
// So even if the window now is "falsely valid", it won't give a result bigger than 5,
// which means the answer stays correct.
//
// This approach is called Lazy Tracking:
// we don't decrease maxFreq when the window shrinks, because overcounting it
// doesn't break correctness and avoids extra computation.
```
