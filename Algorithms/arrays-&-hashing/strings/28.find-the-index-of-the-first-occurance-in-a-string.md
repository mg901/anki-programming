## [28 Find the Index of the First Occurrence in a String 'KMP'](https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/description/)

<!-- notecardId: 1768741407978 -->

```js
// Explanation:
// - Algorithm: Knuth-Morris-Pratt
//    Tushar Roy: https://youtu.be/GTJr8OvyEVQ
//    Roman Tsarev: https://youtu.be/7g-WEBj3igk
//    Inside Code: https://youtu.be/M9azY7YyMqI
//    ByteQuest: https://youtu.be/ynv7bbcSLKE

// - Problem
//    Neetcode: https://youtu.be/JoF0Z7nVSrA

// - Time: O(n + m)
// - Space: O(m)
//    n = haystack.length
//    m = needle.length
function strStr(haystack, needle) {
  const n = haystack.length;
  const m = needle.length;

  if (m === 0) return 0;
  if (m > n) return -1;

  const lps = buildLPS(needle);
  let i = 0;
  let j = 0;

  while (i < n) {
    if (haystack[i] === needle[j]) {
      i += 1;
      j += 1;

      if (j === m) return i - j;
    } else if (j > 0) {
      j = lps[j - 1];
    } else {
      i += 1;
    }
  }

  return -1;
}

// - Time: O(n)
// - Space: O(n)
function buildLPS(pattern) {
  const n = pattern.length;
  const lps = new Array(n).fill(0);
  let length = 0;
  let i = 1;

  while (i < n) {
    if (pattern[i] === pattern[length]) {
      length += 1;
      lps[i] = length;
      i += 1;
    } else if (length > 0) {
      length = lps[length - 1];
    } else {
      i += 1;
    }
  }

  // LPS - Largest Prefix Suffix
  return lps;
}
```

## [28 Find the Index of the First Occurrence in a String 'Boyer-Moore-Horspool'](https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/description/)

<!-- notecardId: 1768741407981 -->

```js
// Explanation:
// - Algorithm: Boyer-Moore-Horspool
//    Roman Tsarev: https://youtu.be/KIUHWMwavQg
//    Mike Slade:

// - Problem
//    Neetcode: https://youtu.be/JoF0Z7nVSrA

// - Time:
//    Best: O(n / m) â‰ˆ O(n)
//    Worst: O(n * m)

// - Space: O(m)
//    where:
//      - m = needle.length
function strStr(haystack, needle) {
  const n = haystack.length;
  const m = needle.length;

  if (m === 0) return 0;
  if (m > n) return -1;

  const shift = {};

  for (let i = 0; i < m - 1; i += 1) {
    shift[needle[i]] = m - 1 - i;
  }

  let start = 0;

  while (start <= n - m) {
    let j = m - 1;

    while (j >= 0 && needle[j] === haystack[start + j]) {
      j -= 1;
    }

    if (j < 0) return start;

    const lastChar = haystack[start + m - 1];
    start += shift[lastChar] ?? m;
  }

  return -1;
```
