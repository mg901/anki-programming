## [460 LFU Cache](https://leetcode.com/problems/lfu-cache/description/)

```js
class ListNode {
  constructor(data, next = null, prev = null) {
    this.data = data;
    this.next = next;
    this.prev = prev;
  }
}

class DoublyLinkedList {
  constructor() {
    this.head = null;
    this.tail = null;
    this.size = 0;
  }

  get isEmpty() {
    return this.head === null;
  }

  append(value) {
    const newNode = new ListNode(value);

    if (this.head === null) {
      this.head = newNode;
      this.tail = newNode;
    } else {
      this.tail.next = newNode;
      newNode.prev = this.tail;
      this.tail = newNode;
    }

    this.size += 1;

    return this;
  }

  deleteByRef(ref) {
    if (ref.next) {
      ref.next.prev = ref.prev;
    } else {
      this.tail = ref.prev;
    }

    if (ref.prev) {
      ref.prev.next = ref.next;
    } else {
      this.head = ref.next;
    }

    ref.next = null;
    ref.prev = null;

    this.size -= 1;
  }

  removeHead() {
    if (this.head === null) return null;

    const removedNode = this.head;

    if (removedNode?.next) {
      this.head = removedNode.next;
      this.head.prev = null;
      this.size -= 1;
    } else {
      this.clear();
    }

    return removedNode;
  }

  clear() {
    this.head = null;
    this.tail = null;
    this.size = 0;
  }
}

class LFUCache {
  #capacity;

  #keyFrequencyMap = new Map();

  #frequencyBuckets = {};

  #keyNodeMap = new Map();

  #INITIAL_FREQUENCY = 1;

  minFrequency = this.#INITIAL_FREQUENCY;

  #size = 0;

  constructor(capacity) {
    this.#capacity = capacity;
  }

  get size() {
    return this.#size;
  }

  get isEmpty() {
    return this.toArray().length === 0;
  }

  put(key, value) {
    if (this.#keyNodeMap.has(key)) {
      this.#removeItem(key);
    }

    if (this.#size === this.#capacity) {
      this.#evictLeastFrequentlyUsed();
    }

    this.#addItem(key, value);
  }

  get(key) {
    if (!this.#keyNodeMap.has(key)) return -1;

    const node = this.#getNode(key);
    const { value } = node.data;
    this.#removeItem(key);
    this.#addItem(key, value);

    return node.data.value;
  }

  clear() {
    this.#keyFrequencyMap.clear();
    this.#frequencyBuckets = {};
    this.#keyNodeMap.clear();
    this.minFrequency = this.#INITIAL_FREQUENCY;
    this.#size = 0;
  }

  #removeItem(key) {
    const node = this.#getNode(key);
    const frequency = this.#getFrequency(key);
    const bucket = this.#frequencyBuckets[frequency];

    bucket.deleteByRef(node);
    this.#size -= 1;

    if (bucket.isEmpty) {
      delete this.#frequencyBuckets[frequency];

      if (frequency === this.minFrequency) {
        this.minFrequency += 1;
      }
    }
  }

  #getNode(key) {
    return this.#keyNodeMap.get(key);
  }

  #evictLeastFrequentlyUsed() {
    const minFreq = this.minFrequency;
    const bucket = this.#frequencyBuckets[minFreq];

    const leastFrequentNode = bucket.removeHead();
    const { key } = leastFrequentNode.data;

    this.#keyNodeMap.delete(key);
    this.#keyFrequencyMap.delete(key);

    this.#size -= 1;
  }

  #addItem(key, value) {
    this.#increaseFrequency(key);
    const frequency = this.#getFrequency(key);

    if (frequency === this.#INITIAL_FREQUENCY) {
      this.minFrequency = frequency;
    }

    const bucket = this.#frequencyBuckets[frequency] ?? new DoublyLinkedList();

    bucket.append({ key, value });
    this.#frequencyBuckets[frequency] = bucket;

    const newNode = bucket.tail;
    this.#keyNodeMap.set(key, newNode);
    this.#keyFrequencyMap.set(key, frequency);

    this.#size += 1;
  }

  #increaseFrequency(key) {
    this.#keyFrequencyMap.set(key, (this.#getFrequency(key) ?? 0) + 1);
  }

  #getFrequency(key) {
    return this.#keyFrequencyMap.get(key);
  }
}
```
