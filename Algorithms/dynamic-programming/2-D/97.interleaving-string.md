## [97 Interleaving String](https://leetcode.com/problems/interleaving-string/description/)

<!-- notecardId: 1754252782618 -->

```js
// Top-down

// Without memo:
// - Time:  O(2^(m + n))        — explore recursion all paths
// - Space: O(m + n)            — recursion stack depth
//
// With memo:
// - Time: O(m * n)             — each (i, j) state computed once
// - Space: O(m * n)            — memo + O(m + n) recursion stack

function isInterleave(s1, s2, s3) {
  const m = s1.length;
  const n = s2.length;
  const t = s3.length;

  if (m + n !== t) return false;

  const memo = new Map();

  return dfs(0, 0);

  function dfs(i, j) {
    const key = `${i},${j}`;
    if (memo.has(key)) return memo.get(key);

    if (i + j === t) return true;

    if (i < m && s1[i] === s3[i + j] && dfs(i + 1, j)) {
      memo.set(key, true);

      return true;
    }

    if (j < n && s2[j] === s3[i + j] && dfs(i, j + 1)) {
      memo.set(key, true);

      return true;
    }

    memo.set(key, false);

    return false;
  }
}

// Bottom-up
// - Time: O(m * n)
// - Space: O(m * n)
function isInterleave(s1, s2, s3) {
  const m = s1.length;
  const n = s2.length;

  if (m + n !== s3.length) return false;

  const dp = Array.from({ length: m + 1 }, () => new Uint8Array(n + 1));
  dp[0][0] = 1;

  for (let i = 0; i <= m; i += 1) {
    for (let j = 0; j <= n; j += 1) {
      const k = i + j - 1;

      if (i > 0 && s1[i - 1] === s3[k] && dp[i - 1][j]) {
        dp[i][j] = 1;
      }

      if (j > 0 && s2[j - 1] === s3[k] && dp[i][j - 1]) {
        dp[i][j] = 1;
      }
    }
  }

  return !!dp[m][n];
}
```
