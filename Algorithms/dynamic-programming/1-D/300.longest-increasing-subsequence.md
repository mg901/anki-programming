## [300 Longest Increasing Subsequence 'top-down'](https://leetcode.com/problems/longest-increasing-subsequence/description/)

<!-- notecardId: 1758391969555 -->

```js
// Explanation:
// - Neetcode: https://youtu.be/cjWnW0hdF1Y

// Without memo:
// - Time:  O(2^n)
// - Space: O(n)
//
// With memo:
// - Time: O(n^2)
// - Space: O(n^2)
function lengthOfLIS(nums) {
  const n = nums.length;
  const memo = new Map();

  return dfs(-1, 0);

  function dfs(prev, current) {
    const key = `${current},${prev}`;

    if (memo.has(key)) return memo.get(key);
    let maxLength = 0;

    for (let i = current; i < n; i += 1) {
      if (prev === -1 || nums[prev] < nums[i]) {
        maxLength = Math.max(maxLength, 1 + dfs(i, i + 1));
      }
    }

    memo.set(key, maxLength);

    return maxLength;
  }
}
```

## [300 Longest Increasing Subsequence 'bottom-up'](https://leetcode.com/problems/longest-increasing-subsequence/description/)

<!-- notecardId: 1758391969557 -->

```js
// Explanation:
// - Neetcode: https://youtu.be/cjWnW0hdF1Y

// Sub-pattern:
// Problem Type: Longest Increasing Subsequence (LIS)

// - Time: O(n^2)
// - Space: O(n)
function lengthOfLIS(nums) {
  const n = nums.length;
  const dp = new Uint32Array(n).fill(1);

  for (let i = 1; i < n; i += 1) {
    for (let j = 0; j < i; j += 1) {
      if (nums[j] < nums[i]) {
        dp[i] = Math.max(dp[i], 1 + dp[j]);
      }
    }
  }

  return Math.max(...dp);
}
```

## [300 Longest Increasing Subsequence 'patience-sort'](https://leetcode.com/problems/longest-increasing-subsequence/description/)

<!-- notecardId: 1765200954947 -->

```js
// Explanation:
// - Patience Sort
//    Tutorial Horizon: https://youtu.be/WNJnsmOoTJs?si=mtIaJPHPfuu6D-z3&t=27

// - Problem:
//    Neetcode: https://youtu.be/cjWnW0hdF1Y

// Approach: Patience Sort (Greedy + Binary Search)

// - Time: O(n log(n))
// - Space: O(n)
function lengthOfLIS(nums) {
  const piles = [];

  for (const num of nums) {
    let left = 0;
    let right = piles.length;

    while (left < right) {
      const mid = left + ((right - left) >> 1);

      if (piles[mid] < num) {
        left = mid + 1;
      } else {
        right = mid;
      }
    }

    piles[left] = num; // minimize tail <- greedy approach
  }

  return piles.length;
}
```
