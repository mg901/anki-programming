## [139 Word Break](https://leetcode.com/problems/word-break/description/)

<!-- notecardId: 1754495231096 -->

```js
// Explanation:
// - Neetcode: https://youtu.be/Sx9NNgInc3A

// Sub-pattern:
// - Partition

// Top-down
//
// Without memo:
// - Time: O(k^n)
//   where:
//    k = average valid words per position
// - Space: O(n) recursion stack
//
// With memo:
// - Time: O(n * w * m)
//   where:
//    n = `str.length`
//    w = number of words in `wordDict`
//    m = max length of a word in `wordDict`
// - Space: O(n) for memo cache and recursion stack
function wordBreak(str, wordDict) {
  const n = str.length;
  const cache = new Int8Array(n).fill(-1);

  return !!dfs(0);

  function dfs(i) {
    if (i === n) return true;
    if (cache[i] !== -1) return cache[i];

    for (const word of wordDict) {
      if (str.startsWith(word, i) && dfs(i + word.length)) {
        cache[i] = 1;

        return 1;
      }
    }

    cache[i] = 0;

    return 0;
  }
}

// Bottom-up
// - Time: O(n * w * m)
//   where:
//    w = wordDict.length
//    m = maximum length of any word in wordDict
// - Space: O(n)
function wordBreak(s, wordDict) {
  const n = s.length;
  const dp = new Uint8Array(n + 1);
  dp[0] = 1;

  for (let i = 1; i <= n; i += 1) {
    for (const word of wordDict) {
      const start = i - word.length;

      if (start < 0) continue;
      if (dp[start] === 0) continue;
      if (s.slice(start, i) !== word) continue;

      dp[i] = 1;
      break;
    }
  }

  return !!dp[n];
}
```
