## [703 Kth Largest Element in a Stream](https://leetcode.com/problems/kth-largest-element-in-a-stream/description/)

<!-- notecardId: 1743519885815 -->

```js
class KthLargest {
  constructor(k, nums) {
    this.k = k;
    this.minHeap = new MinHeap();

    nums.forEach((num) => this.minHeap.insert(num));

    while (this.minHeap.size > k) {
      this.minHeap.poll();
    }
  }

  add(val) {
    this.minHeap.insert(val);
    if (this.minHeap.size > this.k) {
      this.minHeap.poll();
    }

    return this.minHeap.peek();
  }
}

class MinHeap {
  #compare;

  #nodes;

  constructor(
    compare = (a, b) => {
      if (a === b) return 0;

      return a < b ? 1 : -1;
    }
  ) {
    this.#compare = compare;
    this.#nodes = [];
  }

  get size() {
    return this.#nodes.length;
  }

  get isEmpty() {
    return this.#nodes.length === 0;
  }

  peek() {
    return this.#nodes[0] ?? null;
  }

  insert(value) {
    this.#nodes.push(value);
    this.#heapifyUp();

    return this;
  }

  #heapifyUp(index = this.size - 1) {
    while (index > 0) {
      const parentIndex = Math.floor((index - 1) / 2);

      if (this.#isPrior(parentIndex, index)) break;
      this.#swap(index, parentIndex);

      index = parentIndex;
    }
  }

  #isPrior(i, j) {
    return this.#compare(this.#nodes[i], this.#nodes[j]) > 0;
  }

  #swap(i, j) {
    const temp = this.#nodes[j];
    this.#nodes[j] = this.#nodes[i];
    this.#nodes[i] = temp;
  }

  poll() {
    if (this.#nodes.length === 0) return null;
    if (this.#nodes.length === 1) return this.#nodes.pop();

    const min = this.#nodes[0];
    this.#nodes[0] = this.#nodes.pop();
    this.#heapifyDown();

    return min;
  }

  #heapifyDown(index = 0) {
    while (true) {
      let smallestIdx = index;
      let leftChildIdx = index * 2 + 1;
      let rightChildIdx = index * 2 + 2;

      if (
        leftChildIdx < this.size &&
        this.#isPrior(leftChildIdx, smallestIdx)
      ) {
        smallestIdx = leftChildIdx;
      }

      if (
        rightChildIdx < this.size &&
        this.#isPrior(rightChildIdx, smallestIdx)
      ) {
        smallestIdx = rightChildIdx;
      }

      if (smallestIdx === index) break;

      this.#swap(index, smallestIdx);

      index = smallestIdx;
    }
  }

  toArray() {
    return Array.from(this.#nodes);
  }
}
```
