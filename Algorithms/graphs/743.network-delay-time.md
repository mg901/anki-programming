## [743 Network Delay Time 'Dijkstra'](https://leetcode.com/problems/network-delay-time/description/)

<!-- notecardId: 1750166625233 -->

```js
function networkDelayTime(times, n, k) {
  const graph = createGraph(times, n);

  const minpq = new MinPriorityQueue((entry) => entry[0]);
  minpq.enqueue([0, k]);

  const visited = new Set();
  let time = 0;

  while (!minpq.isEmpty()) {
    const [currentTime, vertex] = minpq.dequeue();
    if (visited.has(vertex)) continue;

    visited.add(vertex);
    time = currentTime;

    for (const [neighbor, weight] of graph[vertex]) {
      if (!visited.has(neighbor)) {
        minpq.enqueue([time + weight, neighbor]);
      }
    }
  }

  return visited.size === n ? time : -1;
}

function createGraph(times, n) {
  const graph = Array.from({ length: n + 1 }, () => []);

  for (const [u, v, weight] of times) {
    graph[u].push([v, weight]);
  }

  return graph;
}
```

## [743 Network Delay Time 'Bellman-Ford'](https://leetcode.com/problems/network-delay-time/description/)

<!-- notecardId: 1750166625235 -->

```js
function networkDelayTime(times, n, k) {
  const signalTimes = new Array(n).fill(Infinity);
  signalTimes[k - 1] = 0;

  for (let i = 0; i < n - 1; i += 1) {
    for (const [u, v, weight] of times) {
      signalTimes[v - 1] = Math.min(
        signalTimes[v - 1],
        signalTimes[u - 1] + weight,
      );
    }
  }

  const maxSignalTime = Math.max(...signalTimes);

  return maxSignalTime === Infinity ? -1 : maxSignalTime;
}
```

## [743 Network Delay Time 'Floyd-Warshall'](https://leetcode.com/problems/network-delay-time/description/)

<!-- notecardId: 1750243888400 -->

```js
function networkDelayTime(times, n, k) {
  const signalTimes = Array.from({ length: n }, () => Array(n).fill(Infinity));

  for (let i = 0; i < n; i += 1) signalTimes[i][i] = 0;

  for (const [u, v, weight] of times) {
    signalTimes[u - 1][v - 1] = weight;
  }

  for (let via = 0; via < n; via += 1) {
    for (let i = 0; i < n; i += 1) {
      for (let j = 0; j < n; j += 1) {
        signalTimes[i][j] = Math.min(
          signalTimes[i][j],
          signalTimes[i][via] + signalTimes[via][j],
        );
      }
    }
  }

  for (let i = 0; i < n; i += 1) {
    if (signalTimes[i][i] < 0) {
      throw new Error('Negative weight cycle detected.');
    }
  }

  let maxSignalTime = 0;
  for (let i = 0; i < n; i += 1) {
    if (signalTimes[k - 1][i] === Infinity) return -1;
    maxSignalTime = Math.max(maxSignalTime, signalTimes[k - 1][i]);
  }

  return maxSignalTime;
}
```
