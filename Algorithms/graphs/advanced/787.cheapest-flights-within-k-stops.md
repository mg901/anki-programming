## [787 Cheapest Flights Within K Stops 'Bellman-Ford'](https://leetcode.com/problems/cheapest-flights-within-k-stops/description/)

<!-- notecardId: 1757581050280 -->

```js
// Explanation:
// - Neetcode: https://youtu.be/5eIK3zUdYmE

// Complexity:
// - Time: O(n + (k * E))
// - Space: O(n)
function findCheapestPrice(n, flights, src, dst, k) {
  let prices = new Array(n).fill(Infinity);
  prices[src] = 0;

  for (let i = 0; i <= k; i += 1) {
    const temp = [...prices];

    for (const [from, to, price] of flights) {
      temp[to] = Math.min(temp[to], prices[from] + price);
    }

    prices = temp;
  }

  return prices[dst] === Infinity ? -1 : prices[dst];
}
```

## [787 Cheapest Flights Within K Stops 'SPFA'](https://leetcode.com/problems/cheapest-flights-within-k-stops/description/)

<!-- notecardId: 1757580878375 -->

```js
// Complexity:
// - Time: O(n + E * k)
// - Space: O(n + E)
function findCheapestPrice(n, flights, src, dst, k) {
  const prices = Array(n).fill(Infinity);
  prices[src] = 0;

  const queue = [[src, 0, 0]];
  const graph = createGraph(n, flights);

  while (queue.length) {
    const [u, cost, stops] = queue.shift();
    if (stops > k) continue;

    for (const [v, w] of graph[u]) {
      const nextCost = cost + w;

      if (nextCost < prices[v]) {
        prices[v] = nextCost;
        queue.push([v, nextCost, stops + 1]);
      }
    }
  }

  return prices[dst] === Infinity ? -1 : prices[dst];
}

function createGraph(n, edges) {
  const graph = Array.from({ length: n }, () => []);

  for (const [u, v, w] of edges) {
    graph[u].push([v, w]);
  }

  return graph;
}
```

## [787 Cheapest Flights Within K Stops 'DFS'](https://leetcode.com/problems/cheapest-flights-within-k-stops/description/)

```js
function findCheapestPrice(n, flights, src, dst, k) {
  const graph = createGraph(n, flights);

  const queue = [[src, 0, 0]];
  const prices = new Array(n).fill(Infinity);
  prices[src] = 0;

  let minPrice = Infinity;

  while (queue.length) {
    const [from, cost, stops] = queue.shift();

    if (from === dst) {
      minPrice = Math.min(minPrice, cost);
      continue;
    }

    if (stops > k) continue;

    for (const [to, price] of graph[from]) {
      const newCost = cost + price;

      if (newCost < prices[to] && newCost < minPrice) {
        prices[to] = newCost;
        queue.push([to, newCost, stops + 1]);
      }
    }
  }

  return minPrice === Infinity ? -1 : minPrice;
}

function createGraph(n, edges) {
  const graph = Array.from({ length: n }, () => []);

  for (const [u, v, w] of edges) {
    graph[u].push([v, w]);
  }

  return graph;
}
```
