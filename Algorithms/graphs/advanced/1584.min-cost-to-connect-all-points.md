## [1584 Min Cost to Connect All Points 'Kruskal'](https://leetcode.com/problems/min-cost-to-connect-all-points/description/)

<!-- notecardId: 1757515799129 -->

```js
// Explanation:
// - Neetcode: https://youtu.be/f7JOBJIC-NA

// Algorithm: Kruskal
// Explanation:
// - Abdul Bari: https://youtu.be/4ZlRH0eK-qQ?si=zqtaneX9DVkaR3Gx&t=693
class DisjointSet {
  #parent;

  #rank;

  constructor(n) {
    this.#parent = Array.from({ length: n }, (_, index) => index);
    this.#rank = new Uint32Array(n);
  }

  // O(⍺(n))
  find(x) {
    if (this.#parent[x] !== x) {
      this.#parent[x] = this.find(this.#parent[x]);
    }

    return this.#parent[x];
  }

  // O(⍺(n))
  union(x, y) {
    const rootX = this.find(x);
    const rootY = this.find(y);

    if (rootX === rootY) return false;

    if (this.#rank[rootX] < this.#rank[rootY]) {
      this.#parent[rootX] = rootY;
    } else if (this.#rank[rootX] > this.#rank[rootY]) {
      this.#parent[rootY] = rootX;
    } else {
      this.#parent[rootY] = rootX;
      this.#rank[rootX] += 1;
    }

    return true;
  }
}

// Complexity:
// - Time: O(n² log n)
// - Space: O(n²)
function minCostConnectPoints(points) {
  const n = points.length;
  const edges = [];

  for (let u = 0; u < n; u += 1) {
    for (let v = u + 1; v < n; v += 1) {
      const [ux, uy] = points[u];
      const [vx, vy] = points[v];
      const dist = Math.abs(ux - vx) + Math.abs(uy - vy);

      edges.push([u, v, dist]);
    }
  }

  edges.sort((a, b) => a[2] - b[2]);

  const ds = new DisjointSet(n);
  let cost = 0;
  let count = 0;

  for (let [u, v, w] of edges) {
    if (ds.union(u, v)) {
      cost += w;
      count += 1;
      if (count === n - 1) break;
    }
  }

  return cost;
}
```

## [1584 Min Cost to Connect All Points 'Prim'](https://leetcode.com/problems/min-cost-to-connect-all-points/description/)

<!-- notecardId: 1757509978134 -->

```js
// Explanation:
// - Neetcode: https://youtu.be/f7JOBJIC-NA

// Algorithm: Prim
// Explanation:
// - Abdul Bari: https://youtu.be/4ZlRH0eK-qQ?si=HtVs9yDNVg6DIRNC&t=466

// Complexity:
// - Time: O(n²)
// - Space: O(n)
function minCostConnectPoints(points) {
  const n = points.length;
  const visited = new Uint8Array(n);
  const key = Array(n).fill(Infinity);

  key[0] = 0;
  let cost = 0;

  for (let i = 0; i < n; i += 1) {
    let u = -1;

    for (let v = 0; v < n; v += 1) {
      if (visited[v]) continue;
      if (u === -1 || key[v] < key[u]) {
        u = v;
      }
    }

    visited[u] = 1;
    cost += key[u];

    const [ux, uy] = points[u];
    for (let v = 0; v < n; v += 1) {
      if (visited[v]) continue;

      const [vx, vy] = points[v];
      const dist = Math.abs(ux - vx) + Math.abs(uy - vy);
      key[v] = Math.min(key[v], dist);
    }
  }

  return cost;
}

// Or
function minCostConnectPoints(points) {
  const n = points.length;
  const key = new Array(n).fill(Infinity);
  const visited = new Uint8Array(n);

  let u = 0;
  let nodesConnected = 0;
  let cost = 0;

  while (nodesConnected < n - 1) {
    visited[u] = 1;
    let nextU = -1;

    for (let v = 0; v < n; v += 1) {
      if (visited[v]) continue;

      const [ux, uy] = points[u];
      const [vx, vy] = points[v];
      const dist = Math.abs(ux - vx) + Math.abs(uy - vy);
      key[v] = Math.min(key[v], dist);

      if (nextU === -1 || key[v] < key[nextU]) {
        nextU = v;
      }
    }

    cost += key[nextU];
    u = nextU;
    nodesConnected += 1;
  }

  return cost;
}
```
