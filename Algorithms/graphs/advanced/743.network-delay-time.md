## [743 Network Delay Time 'Dijkstra'](https://leetcode.com/problems/network-delay-time/description/)

<!-- notecardId: 1754134427856 -->

```js
// Dijkstra Algorithm: https://youtu.be/bZkzH5x0SKU?si=UZoRBlCEELJ_TTPe

function networkDelayTime(times, n, k) {
  const graph = createGraph(times, n);

  const minpq = new MinPriorityQueue(([_, weight]) => weight);
  minpq.enqueue([k, 0]);

  const visited = new Set();
  let delayTime = 0;

  while (!minpq.isEmpty()) {
    const [u, currentTime] = minpq.dequeue();
    if (visited.has(u)) continue;

    visited.add(u);
    delayTime = currentTime;

    for (const [v, weight] of graph[u]) {
      if (!visited.has(v)) {
        minpq.enqueue([v, delayTime + weight]);
      }
    }
  }

  return visited.size === n ? delayTime : -1;
}

function createGraph(times, n) {
  const graph = Array.from({ length: n + 1 }, () => []);

  for (const [u, v, weight] of times) {
    graph[u].push([v, weight]);
  }

  return graph;
}
```

## [743 Network Delay Time 'Bellman-Ford'](https://leetcode.com/problems/network-delay-time/description/)

<!-- notecardId: 1753184008076 -->

```js
function networkDelayTime(times, n, k) {
  const dist = new Array(n).fill(Infinity);
  dist[k - 1] = 0;

  for (let i = 0; i < n - 1; i += 1) {
    for (const [u, v, weight] of times) {
      dist[v - 1] = Math.min(dist[v - 1], dist[u - 1] + weight);
    }
  }

  const delayTime = Math.max(...dist);

  return delayTime === Infinity ? -1 : delayTime;
}
```

## [743 Network Delay Time 'Floyd-Warshall'](https://leetcode.com/problems/network-delay-time/description/)

<!-- notecardId: 1753184008077 -->

```js
function networkDelayTime(times, n, k) {
  const dist = Array.from({ length: n }, () => Array(n).fill(Infinity));

  for (let i = 0; i < n; i += 1) dist[i][i] = 0;

  for (const [u, v, weight] of times) {
    dist[u - 1][v - 1] = weight;
  }

  for (let via = 0; via < n; via += 1) {
    for (let i = 0; i < n; i += 1) {
      for (let j = 0; j < n; j += 1) {
        dist[i][j] = Math.min(dist[i][j], dist[i][via] + dist[via][j]);
      }
    }
  }

  for (let i = 0; i < n; i += 1) {
    if (dist[i][i] < 0) {
      throw new Error('Negative weight cycle detected.');
    }
  }

  let delayTime = 0;
  for (let i = 0; i < n; i += 1) {
    if (dist[k - 1][i] === Infinity) return -1;
    delayTime = Math.max(delayTime, dist[k - 1][i]);
  }

  return delayTime;
}
```
