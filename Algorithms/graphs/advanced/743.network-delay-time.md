## [743 Network Delay Time 'Dijkstra'](https://leetcode.com/problems/network-delay-time/description/)

<!-- notecardId: 1757876095863 -->

```js
// Explanation:
// - Neetcode: https://youtu.be/EaphyqKU4PQ

// - Felix Tech Tips: https://youtu.be/bZkzH5x0SKU
// - Abdul Bari: https://youtu.be/XB4MIexjvY0

// Complexity:
// - Time: O(E log(V))
// - Space: O(E + V)
function networkDelayTime(times, n, k) {
  const graph = createGraph(n + 1, times);
  const visited = new Uint8Array(n + 1);
  let maxDelay = 0;
  let count = 0;

  const minpq = new MinPriorityQueue(([_, weight]) => weight);
  minpq.enqueue([k, 0]);

  while (!minpq.isEmpty()) {
    const [u, time] = minpq.dequeue();
    if (visited[u]) continue;

    visited[u] = 1;
    count += 1;
    maxDelay = time;

    for (const [v, w] of graph[u]) {
      if (!visited[v]) {
        minpq.enqueue([v, time + w]);
      }
    }
  }

  return count === n ? maxDelay : -1;
}

function createGraph(n, edges) {
  const graph = Array.from({ length: n }, () => []);

  for (const [u, v, w] of edges) {
    graph[u].push([v, w]);
  }

  return graph;
}
```

## [743 Network Delay Time 'Bellman-Ford'](https://leetcode.com/problems/network-delay-time/description/)

<!-- notecardId: 1756741330009 -->

```js
// Explanation:
// - Abdul Bari: https://youtu.be/FtN3BYH2Zes

// Complexity:
// - Time: O(V^2)
// - Space: O(V)
function networkDelayTime(times, n, k) {
  const dist = new Array(n + 1).fill(Infinity);
  dist[k] = 0;

  for (let i = 1; i <= n - 1; i += 1) {
    for (const [u, v, w] of times) {
      if (dist[u] !== Infinity) {
        dist[v] = Math.min(dist[v], dist[u] + w);
      }
    }
  }

  const maxDelay = Math.max(...dist.slice(1));

  return maxDelay === Infinity ? -1 : maxDelay;
}
```

## [743 Network Delay Time 'Floyd-Warshall'](https://leetcode.com/problems/network-delay-time/description/)

<!-- notecardId: 1757974463756 -->

```js
// Explanation:
// - Abdul Bari: https://youtu.be/oNI0rf2P9gE

// Complexity:
// - Time: O(V^3)
// - Space: O(V^2)
function networkDelayTime(times, n, k) {
  const dist = Array.from({ length: n }, () => new Array(n).fill(Infinity));

  for (let i = 0; i < n; i += 1) dist[i][i] = 0;
  for (const [u, v, w] of times) {
    dist[u - 1][v - 1] = w;
  }

  for (let mid = 0; mid < n; mid += 1) {
    for (let u = 0; u < n; u += 1) {
      for (let v = 0; v < n; v += 1) {
        if (dist[u][mid] !== Infinity && dist[mid][v] !== Infinity) {
          dist[u][v] = Math.min(dist[u][v], dist[u][mid] + dist[mid][v]);
        }
      }
    }
  }

  const maxDelay = Math.max(...dist[k - 1]);

  return maxDelay === Infinity ? -1 : maxDelay;
}
```
